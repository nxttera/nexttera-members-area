---
description: 
globs: *.vue
alwaysApply: false
---
# Component Architecture Rules

## Vue 3 Composition API Standards

### Component Structure Template
```vue
<script setup lang="ts">
// 1. Type definitions
interface Props {
  title: string
  items: Array<{ id: string; name: string }>
  isLoading?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  isLoading: false
})

const emit = defineEmits<{
  select: [item: { id: string; name: string }]
  close: []
}>()

// 2. Composables
const { formatDate } = useBrazilianDate()

// 3. Reactive state
const selectedItem = ref<string | null>(null)

// 4. Computed properties
const filteredItems = computed(() => 
  props.items.filter(item => item.name.toLowerCase().includes(''))
)

// 5. Methods
const handleSelect = (item: { id: string; name: string }) => {
  selectedItem.value = item.id
  emit('select', item)
}

// 6. Lifecycle hooks
onMounted(() => {
  // Initialize component
})
</script>

<template>
  <div class="card bg-base-100 shadow-xl">
    <div class="card-body">
      <h2 class="card-title text-base-content">{{ title }}</h2>
      
      <div v-if="isLoading" class="flex justify-center py-8">
        <div class="loading loading-spinner loading-lg text-primary"></div>
      </div>
      
      <div v-else class="space-y-4">
        <div v-for="item in filteredItems" :key="item.id" class="p-4 rounded-lg bg-base-200">
          <button 
            @click="handleSelect(item)"
            :class="[
              'btn w-full',
              selectedItem === item.id ? 'btn-primary' : 'btn-outline'
            ]"
          >
            {{ item.name }}
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
```

## Component Organization

### Directory Structure
```
components/
├── layout/          # Header, Footer, Sidebar
├── ui/             # BaseModal, BaseInput, BaseButton
├── forms/          # DocumentInput, AddressForm
├── charts/         # Data visualization components
├── tables/         # DataTable, PaginatedTable
└── features/       # Feature-specific components
```

## Composables Patterns

### Data Fetching
```typescript
// composables/useMembers.ts
export const useMembers = () => {
  const members = ref<Member[]>([])
  const isLoading = ref(false)
  const error = ref<string | null>(null)

  const fetchMembers = async () => {
    isLoading.value = true
    try {
      const { data } = await $fetch<{ data: Member[] }>('/api/members')
      members.value = data
    } catch (err) {
      error.value = 'Erro ao carregar membros'
    } finally {
      isLoading.value = false
    }
  }

  return {
    members: readonly(members),
    isLoading: readonly(isLoading),
    error: readonly(error),
    fetchMembers
  }
}
```

### Form Handling
```typescript
// composables/useForm.ts
export const useForm = <T extends Record<string, any>>(
  initialData: T,
  validationRules?: Partial<Record<keyof T, (value: any) => string | null>>
) => {
  const formData = reactive<T>({ ...initialData })
  const errors = reactive<Partial<Record<keyof T, string>>>({})
  const isSubmitting = ref(false)

  const validate = () => {
    if (!validationRules) return true
    // Validation logic
    return true
  }

  const submit = async (submitFn: (data: T) => Promise<any>) => {
    if (!validate()) return
    isSubmitting.value = true
    try {
      await submitFn(formData)
    } finally {
      isSubmitting.value = false
    }
  }

  return { formData, errors, isSubmitting, submit, validate }
}
```

## Base Components

### Modal Component
```vue
<!-- components/ui/BaseModal.vue -->
<script setup lang="ts">
interface Props {
  modelValue: boolean
  title: string
  size?: 'sm' | 'md' | 'lg'
}

const props = withDefaults(defineProps<Props>(), {
  size: 'md'
})

const emit = defineEmits<{
  'update:modelValue': [value: boolean]
}>()

const closeModal = () => emit('update:modelValue', false)
</script>

<template>
  <div :class="['modal', { 'modal-open': modelValue }]" @click.self="closeModal">
    <div class="modal-box">
      <h3 class="font-bold text-lg">{{ title }}</h3>
      <slot />
      <div class="modal-action">
        <slot name="actions" />
      </div>
    </div>
  </div>
</template>
```

### Input Component
```vue
<!-- components/forms/BaseInput.vue -->
<script setup lang="ts">
interface Props {
  modelValue: string
  label: string
  type?: 'text' | 'email' | 'password'
  required?: boolean
  error?: string
}

const props = withDefaults(defineProps<Props>(), {
  type: 'text',
  required: false
})

const emit = defineEmits<{
  'update:modelValue': [value: string]
}>()

const inputValue = computed({
  get: () => props.modelValue,
  set: (value: string) => emit('update:modelValue', value)
})
</script>

<template>
  <div class="form-control w-full">
    <label class="label">
      <span class="label-text">
        {{ label }}
        <span v-if="required" class="text-error">*</span>
      </span>
    </label>
    <input
      v-model="inputValue"
      :type="type"
      :class="['input input-bordered w-full', { 'input-error': error }]"
      :required="required"
    >
    <label v-if="error" class="label">
      <span class="label-text-alt text-error">{{ error }}</span>
    </label>
  </div>
</template>
```

## Performance Guidelines

### Lazy Loading
```vue
<script setup lang="ts">
// Lazy load heavy components
const HeavyComponent = defineAsyncComponent(() => 
  import('~/components/charts/HeavyChart.vue')
)
</script>

<template>
  <Suspense>
    <HeavyComponent />
    <template #fallback>
      <div class="loading loading-spinner loading-lg"></div>
    </template>
  </Suspense>
</template>
```

### Computed Properties
- Use computed for derived state
- Use readonly() for exposing reactive state
- Implement proper memoization for expensive operations

### Event Handling
- Use event delegation for large lists
- Debounce user input events
- Use proper cleanup in onUnmounted

## Testing Standards

### Component Tests
```typescript
// Use Vitest and Vue Test Utils
import { mount } from '@vue/test-utils'
import BaseInput from '~/components/forms/BaseInput.vue'

test('emits update on input', async () => {
  const wrapper = mount(BaseInput, {
    props: { modelValue: '', label: 'Test' }
  })
  
  await wrapper.find('input').setValue('test')
  expect(wrapper.emitted('update:modelValue')).toEqual([['test']])
})
```